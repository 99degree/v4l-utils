#!/usr/bin/perl
use strict;
use Getopt::Long;

#   Copyright (C) 2014 Mauro Carvalho Chehab
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, version 2 of the License.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
# This small script parses USB dumps generated by several drivers,
# decoding USB bits.
#
# To use it, do:
# dmesg | ./parse_usb.pl
#
# Also, there are other utilities that produce similar outputs, and it
# is not hard to parse some USB analyzers log into the expected format.
#

my $debug = 0;
my $show_timestamp = 0;

my $argerr = "Invalid arguments.\nUse $0 [--debug] [--show_timestamp]\n";

GetOptions(
	'show_timestamp' => \$show_timestamp,
	'debug' => \$debug,
) or die $argerr;


my $ctrl_ep = 0x02;
my $resp_ep = 0x81;

my %cmd_map = (
	0x00 => "CMD_MEM_RD",
	0x01 => "CMD_MEM_WR",
	0x02 => "CMD_I2C_RD",
	0x03 => "CMD_I2C_WR",
	0x04 => "CMD_EEPROM_READ",
	0x05 => "CMD_EEPROM_WRITE",
	0x18 => "CMD_IR_GET",
	0x21 => "CMD_FW_DL",
	0x22 => "CMD_FW_QUERYINFO",
	0x23 => "CMD_FW_BOOT",
	0x24 => "CMD_FW_DL_BEGIN",
	0x25 => "CMD_FW_DL_END",
	0x29 => "CMD_FW_SCATTER_WR",
	0x2a => "CMD_GENERIC_I2C_RD",
	0x2b => "CMD_GENERIC_I2C_WR",
);

my @stack;

while (<>) {
	if (m/(\d+)\s+ms\s+(\d+)\s+ms\s+\((\d+)\s+us\s+EP\=([\da-fA-F]+).*[\<\>]+\s*(.*)/) {
		my $timestamp = sprintf "%09u ms %6u ms %7u us ", $1, $2, $3;
		my $ep = hex($4);
		my $payload = $5;

		printf("// %sEP=0x%02x: %s\n", $timestamp, $ep, $payload) if ($debug);

		$timestamp = "" if (!$show_timestamp);

		if ($payload =~ /ERROR/) {
			my $data = pop @stack;
			if ($data) {
				my ( $ctrl_ts, $ctrl_ep, $ctrl_len, $ctrl_seq, $ctrl_mbox, $ctrl_cmd, $ctrl_hsize, @ctrl_bytes ) = @$data;

				printf("%slen=%d, seq %d, mbox=0x%02x, cmd=%s, bytes=",
					$ctrl_ts, $ctrl_len, $ctrl_seq, $ctrl_mbox, $ctrl_cmd);
				for (my $i = $ctrl_hsize; $i < scalar(@ctrl_bytes) - 2; $i++) {
					printf "%02x ", $ctrl_bytes[$i];
				}
				printf("\n");
			}

			printf("\t%sEP=0x%02x: %s\n", $timestamp, $ep, $payload);
			next;
		}

		next if (!($ep == $ctrl_ep || $ep == $resp_ep));

		my @bytes = split(/ /, $payload);
		for (my $i = 0; $i < scalar(@bytes); $i++) {
			$bytes[$i] = hex($bytes[$i]);
		}

		my $len = $bytes[0];
		my $header_size;
		# Discount checksum and header length
		if ($ep == $ctrl_ep) {
			$header_size = 4;
		} else {
			$header_size = 3;
		}
		$len -= 1 + $header_size;
		my $mbox = $bytes[1];
		my $cmd = $bytes[2];
		if (defined($cmd_map{$cmd})) {
			$cmd = $cmd_map{$cmd};
		} else {
			$cmd = sprintf "unknown 0x%02x", $cmd;
		}
		my $seq = $bytes[3];

		if ($ep == $ctrl_ep) {
			my @data = ( $timestamp, $ep, $len, $seq, $mbox, $cmd, $header_size, @bytes );
			push @stack, \@data;
		} else {
			my $data = pop @stack;
			if (!$data) {
				printf "Missing control cmd\n";
			}
			my ( $ctrl_ts, $ctrl_ep, $ctrl_len, $ctrl_seq, $ctrl_mbox, $ctrl_cmd, $ctrl_hsize, @ctrl_bytes ) = @$data;

			printf("%slen=%d, seq %d, mbox=0x%02x, cmd=%s, bytes=",
				$ctrl_ts, $ctrl_len, $ctrl_seq, $ctrl_mbox, $ctrl_cmd);
			for (my $i = $ctrl_hsize; $i < scalar(@ctrl_bytes) - 2; $i++) {
				printf "%02x ", $ctrl_bytes[$i];
			}
			printf("\n");

			printf("\t%slen=%d, seq %d, mbox=0x%02x, cmd=%s, bytes=",
				$timestamp, $len, $seq, $mbox, $cmd);
			# Print everything, except the checksum
			for (my $i = $header_size; $i < scalar(@bytes) - 2; $i++) {
				printf "%02x ", $bytes[$i];
			}
			printf("\n");
		}
	}
}
