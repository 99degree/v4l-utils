#!/usr/bin/perl
use strict;

#   Copyright (C) 2014 Mauro Carvalho Chehab
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, version 2 of the License.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
# This small script parses USB dumps generated by several drivers,
# decoding USB bits.
#
# To use it, do:
# dmesg | ./parse_usb.pl
#
# Also, there are other utilities that produce similar outputs, and it
# is not hard to parse some USB analyzers log into the expected format.
#

my $debug = 1; # FIXME: convert it into a command line option
my $ctrl_ep = 0x02;
my $resp_ep = 0x81;

my %cmd_map = (
	0x00 => "CMD_MEM_RD",
	0x01 => "CMD_MEM_WR",
	0x02 => "CMD_I2C_RD",
	0x03 => "CMD_I2C_WR",
	0x18 => "CMD_IR_GET",
	0x21 => "CMD_FW_DL",
	0x22 => "CMD_FW_QUERYINFO",
	0x23 => "CMD_FW_BOOT",
	0x24 => "CMD_FW_DL_BEGIN",
	0x25 => "CMD_FW_DL_END",
	0x29 => "CMD_FW_SCATTER_WR",
	0x2a => "CMD_GENERIC_I2C_RD",
	0x2b => "CMD_GENERIC_I2C_WR",
);

while (<>) {
	if (m/(\d+)\s+ms\s+(\d+)\s+ms\s+\((\d+)\s+us\s+EP\=([\da-fA-F]+).*[\<\>]+\s*(.*)/) {
		my $timestamp = sprintf "%09u ms %6u ms %6u us", $1, $2, $3;
		my $ep = hex($4);
		my $payload = $5;
		my @bytes = split(/ /, $payload);
		for (my $i = 0; $i < scalar(@bytes); $i++) {
			$bytes[$i] = hex($bytes[$i]);
		}

		printf("// %s EP=0x%02x: %s\n", $timestamp, $ep, $payload) if ($debug);

		next if (!($ep == $ctrl_ep || $ep == $resp_ep));

		my $len = $bytes[0];
		my $header_size;
		# Discount checksum and header length
		if ($ep == $ctrl_ep) {
			$header_size = 4;
		} else {
			$header_size = 3;
		}
		$len -= 1 + $header_size;
		my $mbox = $bytes[1];
		my $cmd = $bytes[2];
		if (defined($cmd_map{$cmd})) {
			$cmd = $cmd_map{$cmd};
		} else {
			$cmd = sprintf "unknown 0x%02x", $cmd;
		}
		my $seq = $bytes[3];

		printf("%s EP=0x%02x: len=%d, seq %d, mbox=0x%02x, cmd=%s, bytes=",
			$timestamp, $ep, $len, $seq, $mbox, $cmd);
		# Print everything, except the checksum
		for (my $i = $header_size; $i < scalar(@bytes) - 2; $i++) {
			printf "%02x ", $bytes[$i];
		}
		printf("\n");
	}
}
