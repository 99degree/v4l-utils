#!/usr/bin/perl

#   Copyright (C) 2011 Mauro Carvalho Chehab <mchehab@redhat.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, version 2 of the License.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
# This small script parses register dumps generated by em28xx driver
# with debug options enabled, generating a source code with the results
# of the dump.
#
# It is a variant of parse_em28xx.pl, meant to be used to decode DRX-K
# register read/writes.
#
# It will provide data output like:
#
# write16_flags(state, 0x52, SIO_CC_PWD_MODE__A, 0x0000, 0xc0);
# write16_flags(state, 0x52, SIO_CC_UPDATE__A, 0xfa00ba, 0xc0);
# write16_flags(state, 0x52, SIO_CC_PLL_LOCK__A, 0x0001, 0xc0);
# write32_flags(state, 0x52, SIO_TOP_COMM_KEY__A, 0x0000, 0xc0);
# write16_flags(state, 0x52, SIO_TOP_COMM_KEY__A, 0xfa00ba, 0xc0);
# write32_flags(state, 0x52, SIO_TOP_JTAGID_LO__A, 0x0000, 0xc0);
# read32_flags(state, 0x52, 0x39846380, 0x0000, 0x90);
#

use strict;

my %reg_map = (
	"0x00" => "EM28XX_R00_CHIPCFG",
	"0x04" => "EM2880_R04_GPO",
	"0x08" => "EM28XX_R08_GPIO",
	"0x06" => "EM28XX_R06_I2C_CLK",
	"0x0a" => "EM28XX_R0A_CHIPID",
	"0x0c" => "EM28XX_R0C_USBSUSP",
	"0x0e" => "EM28XX_R0E_AUDIOSRC",
	"0x0f" => "EM28XX_R0F_XCLK",
	"0x20" => "EM28XX_XCLK_IR_RC5_MODE",
	"0x10" => "EM28XX_R10_VINMODE",
	"0x11" => "EM28XX_R11_VINCTRL",
	"0x12" => "EM28XX_R12_VINENABLE",
	"0x14" => "EM28XX_R14_GAMMA",
	"0x15" => "EM28XX_R15_RGAIN",
	"0x16" => "EM28XX_R16_GGAIN",
	"0x17" => "EM28XX_R17_BGAIN",
	"0x18" => "EM28XX_R18_ROFFSET",
	"0x19" => "EM28XX_R19_GOFFSET",
	"0x1a" => "EM28XX_R1A_BOFFSET",
	"0x1b" => "EM28XX_R1B_OFLOW",
	"0x1c" => "EM28XX_R1C_HSTART",
	"0x1d" => "EM28XX_R1D_VSTART",
	"0x1e" => "EM28XX_R1E_CWIDTH",
	"0x1f" => "EM28XX_R1F_CHEIGHT",
	"0x20" => "EM28XX_R20_YGAIN",
	"0x21" => "EM28XX_R21_YOFFSET",
	"0x22" => "EM28XX_R22_UVGAIN",
	"0x23" => "EM28XX_R23_UOFFSET",
	"0x24" => "EM28XX_R24_VOFFSET",
	"0x25" => "EM28XX_R25_SHARPNESS",
	"0x26" => "EM28XX_R26_COMPR",
	"0x27" => "EM28XX_R27_OUTFMT",
	"0x28" => "EM28XX_R28_XMIN",
	"0x29" => "EM28XX_R29_XMAX",
	"0x2a" => "EM28XX_R2A_YMIN",
	"0x2b" => "EM28XX_R2B_YMAX",
	"0x30" => "EM28XX_R30_HSCALELOW",
	"0x31" => "EM28XX_R31_HSCALEHIGH",
	"0x32" => "EM28XX_R32_VSCALELOW",
	"0x33" => "EM28XX_R33_VSCALEHIGH",
	"0x34" => "EM28XX_R34_VBI_START_H",
	"0x35" => "EM28XX_R35_VBI_START_V",
	"0x36" => "EM28XX_R36_VBI_WIDTH",
	"0x37" => "EM28XX_R37_VBI_HEIGHT",
	"0x40" => "EM28XX_R40_AC97LSB",
	"0x41" => "EM28XX_R41_AC97MSB",
	"0x42" => "EM28XX_R42_AC97ADDR",
	"0x43" => "EM28XX_R43_AC97BUSY",
	"0x45" => "EM28XX_R45_IR",
	"0x50" => "EM2874_R50_IR_CONFIG",
	"0x51" => "EM2874_R51_IR",
	"0x5f" => "EM2874_R5F_TS_ENABLE",
	"0x80" => "EM2874_R80_GPIO",
);

my %ac97_map = (
	"0x00" => "AC97_RESET",
	"0x02" => "AC97_MASTER_VOL",
	"0x04" => "AC97_LINE_LEVEL_VOL",
	"0x06" => "AC97_MASTER_MONO_VOL",
	"0x0a" => "AC97_PC_BEEP_VOL",
	"0x0c" => "AC97_PHONE_VOL",
	"0x0e" => "AC97_MIC_VOL",
	"0x10" => "AC97_LINEIN_VOL",
	"0x12" => "AC97_CD_VOL",
	"0x14" => "AC97_VIDEO_VOL",
	"0x16" => "AC97_AUX_VOL",
	"0x18" => "AC97_PCM_OUT_VOL",
	"0x1a" => "AC97_RECORD_SELECT",
	"0x1c" => "AC97_RECORD_GAIN",
	"0x20" => "AC97_GENERAL_PURPOSE",
	"0x22" => "AC97_3D_CTRL",
	"0x24" => "AC97_AUD_INT_AND_PAG",
	"0x26" => "AC97_POWER_DOWN_CTRL",
	"0x28" => "AC97_EXT_AUD_ID",
	"0x2a" => "AC97_EXT_AUD_CTRL",
	"0x2c" => "AC97_PCM_OUT_FRONT_SRATE",
	"0x2e" => "AC97_PCM_OUT_SURR_SRATE",
	"0x30" => "AC97_PCM_OUT_LFE_SRATE",
	"0x32" => "AC97_PCM_IN_SRATE",
	"0x36" => "AC97_LFE_MASTER_VOL",
	"0x38" => "AC97_SURR_MASTER_VOL",
	"0x3a" => "AC97_SPDIF_OUT_CTRL",
	"0x7c" => "AC97_VENDOR_ID1",
	"0x7e" => "AC97_VENDOR_ID2",

	# em202 specific AC97 registers

	"0x3e" => "EM202_EXT_MODEM_CTRL",
	"0x4c" => "EM202_GPIO_CONF",
	"0x4e" => "EM202_GPIO_POLARITY",
	"0x50" => "EM202_GPIO_STICKY",
	"0x52" => "EM202_GPIO_MASK",
	"0x54" => "EM202_GPIO_STATUS",
	"0x6a" => "EM202_SPDIF_OUT_SEL",
	"0x72" => "EM202_ANTIPOP",
	"0x74" => "EM202_EAPD_GPIO_ACCESS",
);

my ($r40, $r42, $r43, $dir);

sub output_ac97()
{
	if (hex($r42) < 0x80) {
		if ($dir < 0) {
			return;
		}
		$r42 = $ac97_map{$r42} if defined($ac97_map{$r42});
		printf "em28xx_write_ac97(dev, %s, %s);\n",$r42, $r40;
		$r43 = 0;

		return;
	}

	if ($dir > 0) {
		return;
	}
	$r42 = sprintf("0x%02x", hex($r42) - 0x80);
	$r42 = $ac97_map{$r42} if defined($ac97_map{$r42});
	printf "em28xx_read_ac97(dev, %s);\t/* read 0x%s */\n",$r42, $r40;
	$r43 = 0;
}

# DRX-K registers used at the public driver
# Obtained with this command:
#   cat drivers/media/dvb/frontends/drxk_map.h |perl -ne 'if (/define\s+([^\s]+__A)\s+(.*)/) { printf "\t0x%08x => \"%s\",\n",hex($2), $1; }'
#
my %drxk_map = (
	0x01000000 => "AUD_COMM_EXEC__A",
	0x01c00000 => "FEC_COMM_EXEC__A",
	0x01c20000 => "FEC_DI_COMM_EXEC__A",
	0x01c20016 => "FEC_DI_INPUT_CTL__A",
	0x01c30000 => "FEC_RS_COMM_EXEC__A",
	0x01c30012 => "FEC_RS_MEASUREMENT_PERIOD__A",
	0x01c30013 => "FEC_RS_MEASUREMENT_PRESCALE__A",
	0x01c40011 => "FEC_OC_MODE__A",
	0x01c40014 => "FEC_OC_DTO_MODE__A",
	0x01c40015 => "FEC_OC_DTO_PERIOD__A",
	0x01c40018 => "FEC_OC_DTO_BURST_LEN__A",
	0x01c4001a => "FEC_OC_FCT_MODE__A",
	0x01c4001e => "FEC_OC_TMD_MODE__A",
	0x01c4001f => "FEC_OC_TMD_COUNT__A",
	0x01c40020 => "FEC_OC_TMD_HI_MARGIN__A",
	0x01c40021 => "FEC_OC_TMD_LO_MARGIN__A",
	0x01c40023 => "FEC_OC_TMD_INT_UPD_RATE__A",
	0x01c40026 => "FEC_OC_AVR_PARM_A__A",
	0x01c40027 => "FEC_OC_AVR_PARM_B__A",
	0x01c4002e => "FEC_OC_RCN_GAIN__A",
	0x01c40030 => "FEC_OC_RCN_CTL_RATE_LO__A",
	0x01c40032 => "FEC_OC_RCN_CTL_STEP_LO__A",
	0x01c40033 => "FEC_OC_RCN_CTL_STEP_HI__A",
	0x01c40040 => "FEC_OC_SNC_MODE__A",
	0x01c40041 => "FEC_OC_SNC_LWM__A",
	0x01c40042 => "FEC_OC_SNC_HWM__A",
	0x01c40043 => "FEC_OC_SNC_UNLOCK__A",
	0x01c40046 => "FEC_OC_SNC_FAIL_PERIOD__A",
	0x01c40048 => "FEC_OC_IPR_MODE__A",
	0x01c40049 => "FEC_OC_IPR_INVERT__A",
	0x01c40052 => "FEC_OC_OCR_INVERT__A",
	0x01800000 => "IQM_COMM_EXEC__A",
	0x01820010 => "IQM_FS_RATE_OFS_LO__A",
	0x01820014 => "IQM_FS_ADJ_SEL__A",
	0x01830010 => "IQM_FD_RATESEL__A",
	0x01840010 => "IQM_RC_RATE_OFS_LO__A",
	0x01840014 => "IQM_RC_ADJ_SEL__A",
	0x01840016 => "IQM_RC_STRETCH__A",
	0x01860006 => "IQM_CF_COMM_INT_MSK__A",
	0x01860010 => "IQM_CF_SYMMETRIC__A",
	0x01860011 => "IQM_CF_MIDTAP__A",
	0x01860012 => "IQM_CF_OUT_ENA__A",
	0x01860013 => "IQM_CF_ADJ_SEL__A",
	0x01860014 => "IQM_CF_SCALE__A",
	0x01860015 => "IQM_CF_SCALE_SH__A",
	0x01860017 => "IQM_CF_POW_MEAS_LEN__A",
	0x01860019 => "IQM_CF_DS_ENA__A",
	0x01860020 => "IQM_CF_TAP_RE0__A",
	0x01860040 => "IQM_CF_TAP_IM0__A",
	0x01860060 => "IQM_CF_CLP_VAL__A",
	0x01860061 => "IQM_CF_DATATH__A",
	0x01860062 => "IQM_CF_PKDTH__A",
	0x01860063 => "IQM_CF_WND_LEN__A",
	0x01860064 => "IQM_CF_DET_LCT__A",
	0x01860067 => "IQM_CF_BYPASSDET__A",
	0x01870000 => "IQM_AF_COMM_EXEC__A",
	0x01870012 => "IQM_AF_CLKNEG__A",
	0x0187001b => "IQM_AF_START_LOCK__A",
	0x0187001c => "IQM_AF_PHASE0__A",
	0x0187001d => "IQM_AF_PHASE1__A",
	0x0187001e => "IQM_AF_PHASE2__A",
	0x01870023 => "IQM_AF_CLP_LEN__A",
	0x01870024 => "IQM_AF_CLP_TH__A",
	0x01870026 => "IQM_AF_SNS_LEN__A",
	0x01870028 => "IQM_AF_AGC_IF__A",
	0x01870029 => "IQM_AF_AGC_RF__A",
	0x0187002b => "IQM_AF_PDREF__A",
	0x0187002c => "IQM_AF_STDBY__A",
	0x0187002d => "IQM_AF_AMUX__A",
	0x0187002f => "IQM_AF_UPD_SEL__A",
	0x01870034 => "IQM_AF_INC_LCT__A",
	0x01870036 => "IQM_AF_INC_BYPASS__A",
	0x02800000 => "OFDM_CP_COMM_EXEC__A",
	0x03410013 => "OFDM_EC_SB_PRIOR__A",
	0x03010054 => "OFDM_EQ_TOP_TD_TPS_CONST__A",
	0x03010056 => "OFDM_EQ_TOP_TD_TPS_CODE_HP__A",
	0x0301005e => "OFDM_EQ_TOP_TD_SQR_ERR_I__A",
	0x0301005f => "OFDM_EQ_TOP_TD_SQR_ERR_Q__A",
	0x03010060 => "OFDM_EQ_TOP_TD_SQR_ERR_EXP__A",
	0x03010061 => "OFDM_EQ_TOP_TD_REQ_SMB_CNT__A",
	0x03010062 => "OFDM_EQ_TOP_TD_TPS_PWR_OFS__A",
	0x03800000 => "OFDM_LC_COMM_EXEC__A",
	0x03c00000 => "OFDM_SC_COMM_EXEC__A",
	0x03c00001 => "OFDM_SC_COMM_STATE__A",
	0x03c20040 => "OFDM_SC_RA_RAM_PARAM0__A",
	0x03c20041 => "OFDM_SC_RA_RAM_PARAM1__A",
	0x03c20042 => "OFDM_SC_RA_RAM_CMD_ADDR__A",
	0x03c20043 => "OFDM_SC_RA_RAM_CMD__A",
	0x03c20048 => "OFDM_SC_RA_RAM_OP_PARAM__A",
	0x03c2004b => "OFDM_SC_RA_RAM_LOCK__A",
	0x03c2004d => "OFDM_SC_RA_RAM_BE_OPT_DELAY__A",
	0x03c2004e => "OFDM_SC_RA_RAM_BE_OPT_INIT_DELAY__A",
	0x03c2004f => "OFDM_SC_RA_RAM_ECHO_THRES__A",
	0x03c20050 => "OFDM_SC_RA_RAM_CONFIG__A",
	0x03c2007d => "OFDM_SC_RA_RAM_FR_THRES_8K__A",
	0x03c200e0 => "OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A",
	0x03c200e1 => "OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A",
	0x03c200e3 => "OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A",
	0x03c200e4 => "OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A",
	0x03c200f8 => "OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A",
	0x01400000 => "QAM_COMM_EXEC__A",
	0x01430017 => "QAM_SL_ERR_POWER__A",
	0x01440018 => "QAM_DQ_QUAL_FUN0__A",
	0x01440019 => "QAM_DQ_QUAL_FUN1__A",
	0x0144001a => "QAM_DQ_QUAL_FUN2__A",
	0x0144001b => "QAM_DQ_QUAL_FUN3__A",
	0x0144001c => "QAM_DQ_QUAL_FUN4__A",
	0x0144001d => "QAM_DQ_QUAL_FUN5__A",
	0x01450010 => "QAM_LC_MODE__A",
	0x01450018 => "QAM_LC_QUAL_TAB0__A",
	0x01450019 => "QAM_LC_QUAL_TAB1__A",
	0x0145001a => "QAM_LC_QUAL_TAB2__A",
	0x0145001b => "QAM_LC_QUAL_TAB3__A",
	0x0145001c => "QAM_LC_QUAL_TAB4__A",
	0x0145001d => "QAM_LC_QUAL_TAB5__A",
	0x0145001e => "QAM_LC_QUAL_TAB6__A",
	0x0145001f => "QAM_LC_QUAL_TAB8__A",
	0x01450020 => "QAM_LC_QUAL_TAB9__A",
	0x01450021 => "QAM_LC_QUAL_TAB10__A",
	0x01450022 => "QAM_LC_QUAL_TAB12__A",
	0x01450023 => "QAM_LC_QUAL_TAB15__A",
	0x01450024 => "QAM_LC_QUAL_TAB16__A",
	0x01450025 => "QAM_LC_QUAL_TAB20__A",
	0x01450026 => "QAM_LC_QUAL_TAB25__A",
	0x01450028 => "QAM_LC_LPF_FACTORP__A",
	0x01450029 => "QAM_LC_LPF_FACTORI__A",
	0x0145002a => "QAM_LC_RATE_LIMIT__A",
	0x0145002b => "QAM_LC_SYMBOL_FREQ__A",
	0x01470011 => "QAM_SY_TIMEOUT__A",
	0x01470012 => "QAM_SY_SYNC_LWM__A",
	0x01470013 => "QAM_SY_SYNC_AWM__A",
	0x01470014 => "QAM_SY_SYNC_HWM__A",
	0x01470017 => "QAM_SY_SP_INV__A",
	0x00800000 => "SCU_COMM_EXEC__A",
	0x00831ebf => "SCU_RAM_DRIVER_DEBUG__A",
	0x00831ec4 => "SCU_RAM_QAM_FSM_STEP_PERIOD__A",
	0x00831ec7 => "SCU_RAM_GPIO__A",
	0x00831ec8 => "SCU_RAM_AGC_CLP_CTRL_MODE__A",
	0x00831ecb => "SCU_RAM_FEC_ACCUM_PKT_FAILURES__A",
	0x00831f05 => "SCU_RAM_FEC_PRE_RS_BER_FILTER_SH__A",
	0x00831f15 => "SCU_RAM_AGC_FAST_SNS_CTRL_DELAY__A",
	0x00831f17 => "SCU_RAM_AGC_KI_CYCLEN__A",
	0x00831f18 => "SCU_RAM_AGC_SNS_CYCLEN__A",
	0x00831f19 => "SCU_RAM_AGC_RF_SNS_DEV_MAX__A",
	0x00831f1a => "SCU_RAM_AGC_RF_SNS_DEV_MIN__A",
	0x00831f1b => "SCU_RAM_AGC_RF_MAX__A",
	0x00831f24 => "SCU_RAM_AGC_CONFIG__A",
	0x00831f25 => "SCU_RAM_AGC_KI__A",
	0x00831f26 => "SCU_RAM_AGC_KI_RED__A",
	0x00831f27 => "SCU_RAM_AGC_KI_INNERGAIN_MIN__A",
	0x00831f28 => "SCU_RAM_AGC_KI_MINGAIN__A",
	0x00831f29 => "SCU_RAM_AGC_KI_MAXGAIN__A",
	0x00831f2a => "SCU_RAM_AGC_KI_MAXMINGAIN_TH__A",
	0x00831f2b => "SCU_RAM_AGC_KI_MIN__A",
	0x00831f2c => "SCU_RAM_AGC_KI_MAX__A",
	0x00831f2d => "SCU_RAM_AGC_CLP_SUM__A",
	0x00831f2e => "SCU_RAM_AGC_CLP_SUM_MIN__A",
	0x00831f2f => "SCU_RAM_AGC_CLP_SUM_MAX__A",
	0x00831f30 => "SCU_RAM_AGC_CLP_CYCLEN__A",
	0x00831f31 => "SCU_RAM_AGC_CLP_CYCCNT__A",
	0x00831f32 => "SCU_RAM_AGC_CLP_DIR_TO__A",
	0x00831f33 => "SCU_RAM_AGC_CLP_DIR_WD__A",
	0x00831f34 => "SCU_RAM_AGC_CLP_DIR_STP__A",
	0x00831f35 => "SCU_RAM_AGC_SNS_SUM__A",
	0x00831f36 => "SCU_RAM_AGC_SNS_SUM_MIN__A",
	0x00831f37 => "SCU_RAM_AGC_SNS_SUM_MAX__A",
	0x00831f38 => "SCU_RAM_AGC_SNS_CYCCNT__A",
	0x00831f39 => "SCU_RAM_AGC_SNS_DIR_TO__A",
	0x00831f3a => "SCU_RAM_AGC_SNS_DIR_WD__A",
	0x00831f3b => "SCU_RAM_AGC_SNS_DIR_STP__A",
	0x00831f3d => "SCU_RAM_AGC_INGAIN_TGT__A",
	0x00831f3e => "SCU_RAM_AGC_INGAIN_TGT_MIN__A",
	0x00831f3f => "SCU_RAM_AGC_INGAIN_TGT_MAX__A",
	0x00831f40 => "SCU_RAM_AGC_IF_IACCU_HI__A",
	0x00831f41 => "SCU_RAM_AGC_IF_IACCU_LO__A",
	0x00831f42 => "SCU_RAM_AGC_IF_IACCU_HI_TGT__A",
	0x00831f43 => "SCU_RAM_AGC_IF_IACCU_HI_TGT_MIN__A",
	0x00831f44 => "SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A",
	0x00831f45 => "SCU_RAM_AGC_RF_IACCU_HI__A",
	0x00831f46 => "SCU_RAM_AGC_RF_IACCU_LO__A",
	0x00831f47 => "SCU_RAM_AGC_RF_IACCU_HI_CO__A",
	0x00831f84 => "SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A",
	0x00831f85 => "SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A",
	0x00831f86 => "SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A",
	0x00831f87 => "SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A",
	0x00831f88 => "SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A",
	0x00831f89 => "SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A",
	0x00831f8a => "SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A",
	0x00831f8e => "SCU_RAM_QAM_FSM_RTH__A",
	0x00831f8f => "SCU_RAM_QAM_FSM_FTH__A",
	0x00831f90 => "SCU_RAM_QAM_FSM_PTH__A",
	0x00831f91 => "SCU_RAM_QAM_FSM_MTH__A",
	0x00831f92 => "SCU_RAM_QAM_FSM_CTH__A",
	0x00831f93 => "SCU_RAM_QAM_FSM_QTH__A",
	0x00831f94 => "SCU_RAM_QAM_FSM_RATE_LIM__A",
	0x00831f95 => "SCU_RAM_QAM_FSM_FREQ_LIM__A",
	0x00831f96 => "SCU_RAM_QAM_FSM_COUNT_LIM__A",
	0x00831f97 => "SCU_RAM_QAM_LC_CA_COARSE__A",
	0x00831f99 => "SCU_RAM_QAM_LC_CA_FINE__A",
	0x00831f9a => "SCU_RAM_QAM_LC_CP_COARSE__A",
	0x00831f9b => "SCU_RAM_QAM_LC_CP_MEDIUM__A",
	0x00831f9c => "SCU_RAM_QAM_LC_CP_FINE__A",
	0x00831f9d => "SCU_RAM_QAM_LC_CI_COARSE__A",
	0x00831f9e => "SCU_RAM_QAM_LC_CI_MEDIUM__A",
	0x00831f9f => "SCU_RAM_QAM_LC_CI_FINE__A",
	0x00831fa0 => "SCU_RAM_QAM_LC_EP_COARSE__A",
	0x00831fa1 => "SCU_RAM_QAM_LC_EP_MEDIUM__A",
	0x00831fa2 => "SCU_RAM_QAM_LC_EP_FINE__A",
	0x00831fa3 => "SCU_RAM_QAM_LC_EI_COARSE__A",
	0x00831fa4 => "SCU_RAM_QAM_LC_EI_MEDIUM__A",
	0x00831fa5 => "SCU_RAM_QAM_LC_EI_FINE__A",
	0x00831fa6 => "SCU_RAM_QAM_LC_CF_COARSE__A",
	0x00831fa7 => "SCU_RAM_QAM_LC_CF_MEDIUM__A",
	0x00831fa8 => "SCU_RAM_QAM_LC_CF_FINE__A",
	0x00831fa9 => "SCU_RAM_QAM_LC_CF1_COARSE__A",
	0x00831faa => "SCU_RAM_QAM_LC_CF1_MEDIUM__A",
	0x00831fab => "SCU_RAM_QAM_LC_CF1_FINE__A",
	0x00831fac => "SCU_RAM_QAM_SL_SIG_POWER__A",
	0x00831fad => "SCU_RAM_QAM_EQ_CMA_RAD0__A",
	0x00831fae => "SCU_RAM_QAM_EQ_CMA_RAD1__A",
	0x00831faf => "SCU_RAM_QAM_EQ_CMA_RAD2__A",
	0x00831fb0 => "SCU_RAM_QAM_EQ_CMA_RAD3__A",
	0x00831fb1 => "SCU_RAM_QAM_EQ_CMA_RAD4__A",
	0x00831fb2 => "SCU_RAM_QAM_EQ_CMA_RAD5__A",
	0x00831fea => "SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A",
	0x00831feb => "SCU_RAM_DRIVER_VER_HI__A",
	0x00831fec => "SCU_RAM_DRIVER_VER_LO__A",
	0x00831fed => "SCU_RAM_PARAM_15__A",
	0x00831ffc => "SCU_RAM_PARAM_0__A",
	0x00831ffd => "SCU_RAM_COMMAND__A",
	0x0041000f => "SIO_TOP_COMM_KEY__A",
	0x00410012 => "SIO_TOP_JTAGID_LO__A",
	0x00420031 => "SIO_HI_RA_RAM_RES__A",
	0x00420032 => "SIO_HI_RA_RAM_CMD__A",
	0x00420033 => "SIO_HI_RA_RAM_PAR_1__A",
	0x00420034 => "SIO_HI_RA_RAM_PAR_2__A",
	0x00420035 => "SIO_HI_RA_RAM_PAR_3__A",
	0x00420036 => "SIO_HI_RA_RAM_PAR_4__A",
	0x00420037 => "SIO_HI_RA_RAM_PAR_5__A",
	0x00420038 => "SIO_HI_RA_RAM_PAR_6__A",
	0x00450012 => "SIO_CC_PLL_LOCK__A",
	0x00450015 => "SIO_CC_PWD_MODE__A",
	0x00450016 => "SIO_CC_SOFT_RST__A",
	0x00450017 => "SIO_CC_UPDATE__A",
	0x00470010 => "SIO_OFDM_SH_OFDM_RING_ENABLE__A",
	0x00470012 => "SIO_OFDM_SH_OFDM_RING_STATUS__A",
	0x00480000 => "SIO_BL_COMM_EXEC__A",
	0x00480010 => "SIO_BL_STATUS__A",
	0x00480011 => "SIO_BL_MODE__A",
	0x00480012 => "SIO_BL_ENABLE__A",
	0x00480014 => "SIO_BL_TGT_HDR__A",
	0x00480015 => "SIO_BL_TGT_ADDR__A",
	0x00480016 => "SIO_BL_SRC_ADDR__A",
	0x00480017 => "SIO_BL_SRC_LEN__A",
	0x00480018 => "SIO_BL_CHAIN_ADDR__A",
	0x00480019 => "SIO_BL_CHAIN_LEN__A",
	0x007f0010 => "SIO_PDR_MON_CFG__A",
	0x007f0015 => "SIO_PDR_UIO_IN_HI__A",
	0x007f0016 => "SIO_PDR_UIO_OUT_LO__A",
	0x007f001f => "SIO_PDR_OHW_CFG__A",
	0x007f0025 => "SIO_PDR_MSTRT_CFG__A",
	0x007f0026 => "SIO_PDR_MERR_CFG__A",
	0x007f0028 => "SIO_PDR_MCLK_CFG__A",
	0x007f0029 => "SIO_PDR_MVAL_CFG__A",
	0x007f002a => "SIO_PDR_MD0_CFG__A",
	0x007f002b => "SIO_PDR_MD1_CFG__A",
	0x007f002c => "SIO_PDR_MD2_CFG__A",
	0x007f002d => "SIO_PDR_MD3_CFG__A",
	0x007f002f => "SIO_PDR_MD4_CFG__A",
	0x007f0030 => "SIO_PDR_MD5_CFG__A",
	0x007f0031 => "SIO_PDR_MD6_CFG__A",
	0x007f0032 => "SIO_PDR_MD7_CFG__A",
	0x007f0038 => "SIO_PDR_SMA_TX_CFG__A",
);

sub parse_drxk_addr($$$$)
{
	my $addr = shift;
	my $n = shift;
	my $app_data = shift;
	my $write = shift;

	my ($reg, $flags, $cmd, $bits);

	$n = hex($n);

	if (($n == 4) || ($n == 6) || ($n == 8)) {
		my $r0 = hex(substr($app_data, 0, 2));
		my $r1 = hex(substr($app_data, 3, 2));
		$n -= 2;
		my $j = 6;

		if ($r0 & 1) {
			# Decode a Long format
			my $r2 = hex(substr($app_data, 6, 2));
			my $r3 = hex(substr($app_data, 9, 2));
			$n -= 2;
			$j += 6;

			$reg = ($r0 >> 1) |
			       ($r1 << 16) |
			       (($r2 & 0x0f) << 24) |
			       ($r3 << 7);

			$flags = $r2 & 0xf0;
		} else {
			$flags = 0;
			$reg = ($r0 >> 1) |
			       ($r1 & 0x0f << 16) |
			       ($r1 & 0xf0 << 18);
		}

		if (defined($drxk_map{$reg})) {
			$reg = $drxk_map{$reg};
		} else {
			$reg = "0x" . $reg;
		}

		my $data = hex(substr($app_data, $j, 2)) |
			   hex(substr($app_data, $j + 3, 2)) << 16;

		$data |= hex(substr($app_data, $j + 6, 2)) << 24 |
			 hex(substr($app_data, $j + 9, 2)) << 8 if ($n > 2);

		if ($write) {
			$cmd = "write";
		} else {
			$cmd = "read";
		}

		if ($n == 2) {
			$bits = 16;
		} else {
			$bits = 32;
		}

		if ($flags) {
			printf "%s%d_flags(state, 0x%s, %s, 0x%04x, 0x%02x);\n", $cmd, $bits, $addr, $reg, $data, $flags;
		} else {
			printf "%s%d(state, 0x%s, %s, 0x%04x, %d);\n", $cmd, $bits, $addr, $reg, $data;
		}
	} else {
		if ($write) {
			printf "i2c_master_send(0x%02x>>1, { %s }, %d);\n", $addr, $app_data, $n;
		} else {
			printf "i2c_master_recv(0x%02x>>1, { %s }, %d);\n", $addr, $app_data, $n;
		}
	}
}

##############
# Main program
##############

while (<>) {
	tr/A-F/a-f/;
	if (m/c0 00 00 00 ([0-9a-f].) 00 01 00\s+[\<]+\s+([0-9a-f].)/) {
		if ($1 eq "43" && $2 eq "00") {
			$r43 = 1;
			$r40 = -1;
			$r42 = -1;
			$dir = 0;
			next;
		}

		my $reg = "0x$1";
		$reg = $reg_map{$reg} if defined($reg_map{$reg});

		printf "em28xx_read_reg(dev, %s);\t\t/* read 0x%s */\n",
			$reg, $2;
		next;
	}
	if (m/40 00 00 00 ([0-9a-f].) 00 01 00\s+[\>]+\s+([0-9a-f].)/) {
		if ($r43 == 1) {
			if ($1 eq "42") {
				$r42 = "0x$2";
				if ($r40 >= 0) {
					output_ac97();
					next;
				}
				next;
			}
			$r43 = 0;
		}

		my $reg = "0x$1";
		$reg = $reg_map{$reg} if defined($reg_map{$reg});

		printf "em28xx_write_reg(dev, %s, 0x%s);\n",
			$reg, $2;
		next;
	}
	if (m/c0 00 00 00 ([0-9a-f].) 00 02 00\s+[\<]+\s+([0-9a-f].) ([0-9a-f].)/) {
		if ($r43 == 1) {
			if ($1 eq "40") {
				$r40 = "0x$3$2";
				$dir = -1;

				if ($r42 >= 0) {
					output_ac97();
					next;
				}
				next;
			}
			$r43 = 0;
		}
		my $reg = "0x$1";
		$reg = $reg_map{$reg} if defined($reg_map{$reg});

		printf "em28xx_read_reg16(dev, %s);\t\t/*read 0x%s%s */\n",
			$reg, $3, $2;
		next;
	}
	if (m/40 00 00 00 ([0-9a-f].) 00 02 00\s+[\>]+\s+([0-9a-f].) ([0-9a-f].)/) {
		if ($r43 == 1) {
			if ($1 eq "40") {
				$r40 = "0x$3$2";
				$dir = 1;

				if ($r42 >= 0) {
					output_ac97();
					next;
				}
				next;
			}
			$r43 = 0;
		}
		my $reg = "0x$1";
		$reg = $reg_map{$reg} if defined($reg_map{$reg});

		printf "em28xx_write_reg16(dev, %s,0x%s%s);\n",
			$reg, $3, $2;
		next;
	}

	if (m/40 0[23] 00 00 ([0-9a-f].) 00 ([0-9a-f].) 00\s+[\>]+\s+([0-9a-f ]+)/) {
		if ($1 eq "52") {
			parse_drxk_addr($1, $2, $3, 1);
		} else {
			printf "i2c_master_send(0x$1>>1, { $3 }, 0x$2);\n";
		}
		next;
	}
	if (m/c0 0[23] 00 00 ([0-9a-f].) 00 ([0-9a-f].) 00\s+[\<]+\s+([0-9a-f ]+)/) {
		if ($1 eq "52") {
			parse_drxk_addr($1, $2, $3, 0);
		} else {
			printf "i2c_master_recv(0x$1>>1, &buf, 0x$2); /* $3 */\n";
		}
		next;
	}
	if (m/c0 0[23] 00 00 ([0-9a-f].) 00 ([0-9a-f].) 00\s+[\<]+/) {
		printf "i2c_master_recv(0x$1>>1, &buf, 0x$2); /* nothing returned */\n";
		next;
	}
}
